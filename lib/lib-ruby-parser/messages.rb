# This file is autogenerated by codegen/messages_rb.rs

# Root module
module LibRubyParser
  # Module with all known DiagnosticMessage sub-types
  module Messages
    # Emitted for code
    #
    # @example
    #  1.2.3
    #
    class FractionAfterNumeric < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  foo.2
    #
    class NoDigitsAfterDot < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  %k[foo]
    #
    class UnknownTypeOfPercentString < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  0b
    #
    class NumericLiteralWithoutDigits < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  %w[foo bar
    #
    class UnterminatedList < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  /foo
    #
    class UnterminatedRegexp < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  "foo
    #
    class UnterminatedString < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  %s
    #  //    ^ EOF, not "
    #
    #
    class UnterminatedQuotedString < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  "\ufoo"
    #
    class InvalidUnicodeEscape < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  "\u{999999}"
    #
    class TooLargeUnicodeCodepoint < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  "\u{d800}"
    #
    class InvalidUnicodeCodepoint < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  ?\u{41 42}
    #
    class MultipleCodepointAtSingleChar < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  "\M-"
    #
    class InvalidEscapeCharacter < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  "\xZZ"
    #
    class InvalidHexEscape < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  <<-HERE
    #
    class UnterminatedHeredoc < DiagnosticMessage
      # Heredoc identifier
      #
      # @return [String]
      attr_reader :heredoc_id

    end

    # Emitted for code like
    #
    # @example
    #  <<-"HERE
    #
    class UnterminatedHeredocId < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  eval("foo \r = 42")
    #
    class SlashRAtMiddleOfLine < DiagnosticMessage
    end

    # Emitted for code like (only in $VERBOSE mode)
    #
    # @example
    #  foo **arg
    #
    class DStarInterpretedAsArgPrefix < DiagnosticMessage
    end

    # Emitted for code like (only in $VERBOSE mode)
    #
    # @example
    #  foo *arg
    #
    class StarInterpretedAsArgPrefix < DiagnosticMessage
    end

    # Emitted for code like (only in $VERBOSE mode)
    #
    # @example
    #  foo &arg
    #
    class AmpersandInterpretedAsArgPrefix < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  range = 1...
    #
    class TripleDotAtEol < DiagnosticMessage
    end

    # Emitted for code like (only in $VERBOSE mode)
    #
    # @example
    #  def m (a, b, c); end
    #
    class ParenthesesIterpretedAsArglist < DiagnosticMessage
    end

    # Emitted for code like (only in $VERBOSE mode)
    #
    # @example
    #  m +foo
    #
    class AmbiguousFirstArgument < DiagnosticMessage
      # Operator that is ambiguous
      #
      # @return [Integer]
      attr_reader :operator

    end

    # Emitted for code like (only in $VERBOSE mode)
    #
    # @example
    #  1 *2
    #
    class AmbiguousOperator < DiagnosticMessage
      # Operator that is ambiguous
      #
      # @return [String]
      attr_reader :operator

      # Interpretation of this operator
      #
      # @return [String]
      attr_reader :interpreted_as

    end

    # Emitted for code like
    #
    # @example
    #  "\M- "
    #
    class InvalidCharacterSyntax < DiagnosticMessage
      # Valid syntax sugestions
      #
      # @return [String]
      attr_reader :suggestion

    end

    # Emitted for code like
    #
    # @example
    #  09
    #
    class InvalidOctalDigit < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  0_a
    #
    class TrailingCharInNumber < DiagnosticMessage
      # Invalid trailing char
      #
      # @return [Integer]
      attr_reader :c

    end

    # Emitted for code like
    #
    # @example
    #  =begin
    #
    class EmbeddedDocumentMeetsEof < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  eval("\x01foo")
    #
    class InvalidChar < DiagnosticMessage
      # char
      #
      # @return [Integer]
      attr_reader :c

    end

    # It is unknown how to trigger this error.
    # Code that triggers it in MRI can be dead.
    class IncompleteCharacterSyntax < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  $
    #
    class GvarWithoutId < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  $@
    #
    class InvalidGvarName < DiagnosticMessage
      # char after +$+
      #
      # @return [Integer]
      attr_reader :c

    end

    # Emitted for code like
    #
    # @example
    #  @
    #
    class IvarWithoutId < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  @1
    #
    class InvalidIvarName < DiagnosticMessage
      # char after +@+
      #
      # @return [Integer]
      attr_reader :c

    end

    # Emitted for code like
    #
    # @example
    #  @@
    #
    class CvarWithoutId < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  @@1
    #
    class InvalidCvarName < DiagnosticMessage
      # char after +@@+
      #
      # @return [Integer]
      attr_reader :c

    end

    # Emitted for code like
    #
    # @example
    #  /re/foo
    #
    class UnknownRegexOptions < DiagnosticMessage
      # Concatenated unknown options
      #
      # @return [String]
      attr_reader :options

    end

    # Emitted for code like
    #
    # @example
    #  "\u{1234"
    #
    class UnterminatedUnicodeEscape < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  # encoding: foo
    #
    class EncodingError < DiagnosticMessage
      # Error from decoder
      #
      # @return [String]
      attr_reader :error

    end

    # Emitter for code like
    #
    # @example
    #  eval("\xFF = 42")
    #
    class InvalidMultibyteChar < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  a ?AA : 2
    #
    class AmbiguousTernaryOperator < DiagnosticMessage
      # Source of the condition expression
      #
      # @return [String]
      attr_reader :condition

    end

    # Emitted for code like
    #
    # @example
    #  m /foo/
    #
    class AmbiguousRegexp < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  begin; else; end
    #
    class ElseWithoutRescue < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  def f; BEGIN{}; end
    #
    class BeginNotAtTopLevel < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  alias $a $1
    #
    class AliasNthRef < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  *a&.x = 0
    #
    class CsendInsideMasgn < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  module foo; end
    #
    class ClassOrModuleNameMustBeConstant < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  def foo=() = 42
    #
    class EndlessSetterDefinition < DiagnosticMessage
    end

    # Emitted for any code that produces invalid sequence of tokens
    class UnexpectedToken < DiagnosticMessage
      # Name of the token
      #
      # @return [String]
      attr_reader :token_name

    end

    # Emitted for code like
    #
    # @example
    #  def a; class Foo; end; end
    #
    class ClassDefinitionInMethodBody < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  def a; module Foo; end; end
    #
    class ModuleDefinitionInMethodBody < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  class A; return; end
    #
    class InvalidReturnInClassOrModuleBody < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  def foo(Abc); end
    #
    class ConstArgument < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  def foo(@abc); end
    #
    class IvarArgument < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  def foo($abc); end
    #
    class GvarArgument < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  def foo(@@abc); end
    #
    class CvarArgument < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  case 0; in ^a; true; end
    #
    class NoSuchLocalVariable < DiagnosticMessage
      # Variable name
      #
      # @return [String]
      attr_reader :var_name

    end

    # Emitted for code like
    #
    # @example
    #  m { |a| _1 }
    #
    class OrdinaryParamDefined < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  foo { _1; bar { _2 }; }
    #
    class NumparamUsed < DiagnosticMessage
    end

    # Emitted for code like (only in $VERBOSE mode)
    #
    # @example
    #  if
    #  42
    #  end
    #
    class TokAtEolWithoutExpression < DiagnosticMessage
      # Name of the token
      #
      # @return [String]
      attr_reader :token_name

    end

    # Emitted for code like
    #
    # @example
    #  def m; END {}; end
    #
    class EndInMethod < DiagnosticMessage
    end

    # Emitted for code like (only in $VERBOSE mode)
    #
    # @example
    #  a < b < c
    #
    class ComparisonAfterComparison < DiagnosticMessage
      # Source of the first comparison
      #
      # @return [String]
      attr_reader :comparison

    end

    # Emitted for code like
    #
    # @example
    #  def m(foo = foo) end
    #
    class CircularArgumentReference < DiagnosticMessage
      # Name of the argument
      #
      # @return [String]
      attr_reader :arg_name

    end

    # Emitted for code like
    #
    # @example
    #  def m; FOO = 1; end
    #
    class DynamicConstantAssignment < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  self = foo
    #
    class CantAssignToSelf < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  nil = foo
    #
    class CantAssignToNil < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  true = foo
    #
    class CantAssignToTrue < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  false = foo
    #
    class CantAssignToFalse < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  __FILE__ = foo
    #
    class CantAssignToFile < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  __LINE__ = foo
    #
    class CantAssignToLine < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  __ENCODING__ = foo
    #
    class CantAssignToEncoding < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  proc {_1; _1 = nil}
    #
    class CantAssignToNumparam < DiagnosticMessage
      # Source of the numbered parameter
      #
      # @return [String]
      attr_reader :numparam

    end

    # Emitted for code like
    #
    # @example
    #  $1 = foo
    #
    class CantSetVariable < DiagnosticMessage
      # Source of the read-only variable that is assigned
      #
      # @return [String]
      attr_reader :var_name

    end

    # Emitted for code like
    #
    # @example
    #  yield(&foo)
    #
    class BlockGivenToYield < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  fun(&bar) do end
    #
    class BlockAndBlockArgGiven < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  case a; in "#{a}": 1; end
    #
    class SymbolLiteralWithInterpolation < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  _1 = 1
    #
    class ReservedForNumparam < DiagnosticMessage
      # Numbered parameter that is treated as a local variable
      #
      # @return [String]
      attr_reader :numparam

    end

    # Emitted for code like
    #
    # @example
    #  case a; in a?:; end
    #
    class KeyMustBeValidAsLocalVariable < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  case 0; in a, a; end
    #
    class DuplicateVariableName < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  case 0; in a: 1, a: 2; end
    #
    class DuplicateKeyName < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  def (1).foo; end
    #
    class SingletonLiteral < DiagnosticMessage
    end

    # Emitted for code like (only in $VERBOSE mode)
    #
    # @example
    #  $100
    #
    class NthRefIsTooBig < DiagnosticMessage
      # Source of the nth_ref that is techincally a regular global variable
      #
      # @return [String]
      attr_reader :nth_ref

    end

    # Emitted for code like
    #
    # @example
    #  def foo(aa, aa); end
    #
    class DuplicatedArgumentName < DiagnosticMessage
    end

    # Emitted for code like
    #
    # @example
    #  /[/
    #
    class RegexError < DiagnosticMessage
      # Error from Onigurama engine
      #
      # @return [String]
      attr_reader :error

    end

    # Emitted for code like
    #
    # @example
    #  %I"x .\xc3."
    #
    class InvalidSymbol < DiagnosticMessage
      # Source of the symbol
      #
      # @return [String]
      attr_reader :symbol

    end

    # Emitted for code like
    #
    # @example
    #  a = return
    #
    class VoidValueExpression < DiagnosticMessage
    end

  end
end
