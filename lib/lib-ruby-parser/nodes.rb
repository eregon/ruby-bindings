# This file is autogenerated by codegen/nodes_rb.rs

# Root module
module LibRubyParser
  # Module with all known Node sub-types
  module Nodes
    # Represents +alias to from+ statement.
    class Alias < Node
      # Target of the +alias+.
      #
      # +Sym("foo")+ node for +alias :foo :bar+
      #
      # @return [Node]
      attr_reader :to

      # Source of the +alias+.
      #
      # +Sym("bar")+ node for +alias :foo :bar+
      #
      # @return [Node]
      attr_reader :from

      # Location of the +alias+ keyword
      #
      # @example
      #  alias foo bar
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the full expression
      #
      # @example
      #  alias foo bar
      #  ~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents +foo && bar+ (or +foo and bar+) statement.
    class And < Node
      # Left hand statament of the +&&+ operation.
      #
      # +Lvar("foo")+ node for +foo && bar+
      #
      # @return [Node]
      attr_reader :lhs

      # Right hand statement of the +&&+ operation.
      #
      # +Lvar("bar")+ node for +foo && bar+
      #
      # @return [Node]
      attr_reader :rhs

      # Location of the +&&+ (or +and+) operator
      #
      # @example
      #  a && b
      #    ~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  a && b
      #  ~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents +a &&= 1+ statement.
    class AndAsgn < Node
      # Receiver of the +&&=+ operation.
      #
      # +Lvasgn("a")+ node for +a &&= 1+
      #
      # @return [Node]
      attr_reader :recv

      # Right hand statement of assignment
      #
      # +Int("1")+ node for +a &&= 1+
      #
      # @return [Node]
      attr_reader :value

      # Location of the +&&=+ operator
      #
      # @example
      #  a &&= 1
      #    ~~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  a &&= 1
      #  ~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a positional required block/method argument.
    #
    # +a+ in +def m(a); end+ or +proc { |a| }+
    class Arg < Node
      # Name of the argument
      #
      # @return [String]
      attr_reader :name

      # Location of the full expression
      #
      # @example
      #  def m(argument); end
      #        ~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an arguments list
    #
    # +Args(vec![Arg("a"), Optarg("b", Int("1"))])+ in +def m(a, b = 1); end+
    class Args < Node
      # List of arguments
      #
      # @return [::Array<Node>]
      attr_reader :args

      # Location of the full expression
      #
      # @example
      #  def m(a, b = 1, c:, &blk); end
      #       ~~~~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

      # Location of the open parenthesis
      #
      # @example
      #  def m(a, b = 1, c:, &blk); end
      #       ~
      #
      # +None+ for code like +def m; end+ or +def m arg; end+
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the closing parenthesis
      #
      # @example
      #  def m(a, b = 1, c:, &blk); end
      #                          ~
      #
      # +None+ for code like +def m; end+ or +def m arg; end+
      #
      # @return [Loc, nil]
      attr_reader :end_l

    end

    # Represents an array literal
    class Array < Node
      # A list of elements
      #
      # @return [::Array<Node>]
      attr_reader :elements

      # Location of the open bracket
      #
      # @example
      #  [1, 2, 3]
      #  ~
      #
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the closing bracket
      #
      # @example
      #  [1, 2, 3]
      #          ~
      #
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  [1, 2, 3]
      #  ~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an array pattern used in pattern matching
    class ArrayPattern < Node
      # A list of elements
      #
      # @return [::Array<Node>]
      attr_reader :elements

      # Location of the open bracket
      #
      # @example
      #  [1, ^a, 3 => foo]
      #  ~
      #
      # +None+ for pattern like +1, 2+ without brackets
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the closing bracket
      #
      # @example
      #  [1, ^a, 3 => foo]
      #                  ~
      #
      # +None+ for pattern like +1, 2+ without brackets
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  [1, ^a, 3 => foo]
      #  ~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an array pattern *with trailing comma* used in pattern matching
    #
    # It's slightly different from +ArrayPattern+, trailing comma at the end works as +, *+
    class ArrayPatternWithTail < Node
      # A list of elements
      #
      # @return [::Array<Node>]
      attr_reader :elements

      # Location of the open bracket
      #
      # @example
      #  [1, ^a, 3 => foo,]
      #  ~
      #
      # +None+ for pattern like +1, 2,+ without brackets
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the closing bracket
      #
      # @example
      #  [1, ^a, 3 => foo,]
      #                   ~
      #
      # +None+ for pattern like +1, 2,+ without brackets
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  [1, ^a, 3 => foo,]
      #  ~~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents special global variables:
    # 1. +&` +
    # 2. +$&+
    # 3. +$'+
    # 4. +$++
    class BackRef < Node
      # Name of the variable (+"$+"+ for +$++)
      #
      # @return [String]
      attr_reader :name

      # Location of the full expression
      #
      # @example
      #  $+
      #  ~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents compound statement (i.e. a multi-statement)
    #
    # Basically all blocks of code are wrapped into +Begin+ node (e.g. method/block body, rescue/ensure handler etc)
    class Begin < Node
      # A list of statements
      #
      # @return [::Array<Node>]
      attr_reader :statements

      # Begin of the block
      #
      # @example
      #  (1; 2)
      #  ~
      #
      # +None+ if the block of code is "implicit", like
      #
      # @example
      #  if true; 1; 2; end
      #
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # End of the block
      #
      # @example
      #  (1; 2)
      #       ~
      #
      # +None+ if the block of code is "implicit", like
      #
      # @example
      #  if true; 1; 2; end
      #
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  (1; 2)
      #  ~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a Ruby block that is passed to a method (+proc { |foo| bar }+)
    class Block < Node
      # Method call that takes a block
      #
      # +Send("foo")+ in +foo {}+
      #
      # @return [Node]
      attr_reader :call

      # A list of argument that block takes
      #
      # +vec![ Arg("a"), Optarg("b", Int("1")) ]+ for +proc { |a, b = 1| }+
      #
      # +None+ if the block takes no arguments
      #
      # @return [Node, nil]
      attr_reader :args

      # Block body, +None+ if block has no body.
      #
      # @return [Node, nil]
      attr_reader :body

      # Location of the open brace
      #
      # @example
      #  proc { }
      #       ~
      #
      #
      # @return [Loc]
      attr_reader :begin_l

      # Location of the closing brace
      #
      # @example
      #  proc { }
      #         ~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  proc { }
      #  ~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a +&blk+ argument in the method definition (but not in the method call, see +BlockPass+)
    class Blockarg < Node
      # Name of the argument, +String("foo")+ for +def m(&foo)+
      #
      # @return [String]
      attr_reader :name

      # Location of the +&+ operator
      #
      # @example
      #  def m(&foo); end
      #        ~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the name
      #
      # @example
      #  def m(&foo); end
      #         ~~~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the full expression
      #
      # @example
      #  def m(&foo); end
      #        ~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a +&blk+ argument of the method call (but not of the method definition, see +BlockArg+)
    class BlockPass < Node
      # Value that is converted to a block
      #
      # +Int("1")+ in +foo(&1)+ (yes, it's possible)
      #
      # @return [Node]
      attr_reader :value

      # Location of the +&+ operator
      #
      # @example
      #  foo(&blk)
      #      ~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  foo(&bar)
      #      ~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a +break+ keyword (with optional argument)
    class Break < Node
      # A list of arguments
      #
      # @return [::Array<Node>]
      attr_reader :args

      # Location of the +break+ keyword
      #
      # @example
      #  break :foo
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the full expression
      #
      # @example
      #  break(:foo)
      #  ~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a +case+ statement (for pattern matching see +CaseMatch+ node)
    class Case < Node
      # Expression given to +case+, +Int("1")+ for +case 1; end+
      # +None+ for code like
      #
      # @example
      #  case
      #  when pattern
      #  end
      #
      #
      # @return [Node, nil]
      attr_reader :expr

      # A list of +When+ nodes (each has +patterns+ and +body+)
      #
      # @return [::Array<Node>]
      attr_reader :when_bodies

      # Body of the +else+ branch, +None+ if there's no +else+ branch
      #
      # @return [Node, nil]
      attr_reader :else_body

      # Location of the +case+ keyword
      #
      # @example
      #  case 1; end
      #  ~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +else+ keyword
      #
      # @example
      #  case 1; else; end
      #          ~~~~
      #
      # +None+ if there's no +else+ branch
      #
      # @return [Loc, nil]
      attr_reader :else_l

      # Location of the +end+ keyword
      #
      # @example
      #  case 1; end
      #          ~~~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  case 1; end
      #  ~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a +case+ statement used for pattern matching (for regular +case+ see +Case+ node)
    class CaseMatch < Node
      # Expression given to +case+, +Int("1")+ for +case 1; in 1; end+
      # +None+ for code like
      #
      # @example
      #  case
      #  in pattern
      #  end
      #
      #
      # @return [Node]
      attr_reader :expr

      # A list of +InPattern+ nodes (each has +pattern+, +guard+ and +body+)
      #
      # @return [::Array<Node>]
      attr_reader :in_bodies

      # Body of the +else+ branch, +None+ if there's no +else+ branch
      #
      # @return [Node, nil]
      attr_reader :else_body

      # Location of the +case+ keyword
      #
      # @example
      #  case 1; in 2; end
      #  ~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +else+ keyword
      #
      # @example
      #  case 1; in 2; else; end
      #                ~~~~
      #
      # +None+ if there's no +else+ branch
      #
      # @return [Loc, nil]
      attr_reader :else_l

      # Location of the +end+ keyword
      #
      # @example
      #  case 1; in 2; end
      #                ~~~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  case 1; in 2; end
      #  ~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a constant assignment (i.e. +A = 1+)
    class Casgn < Node
      # Scope where the constant is defined:
      # 1. +Some(Const("A"))+ for +A::B = 1+
      # 2. +None+ if it's defined in the current scope (i.e. +A = 1+)
      # 3. +Some(Cbase)+ if it's defined in the global scope (i.e. +::A = 1+)
      #
      # @return [Node, nil]
      attr_reader :scope

      # Name of the constant, +String("A")+ for +A = 1+
      #
      # @return [String]
      attr_reader :name

      # Value that is assigned to a constant, +Int("1")+ for +A = 1+.
      #
      # **Note**: +None+ if constant assignment is a part of the multi-assignment.
      # In such case +value+ belongs to +Masgn+ node of the multi-assignment.
      #
      # @return [Node, nil]
      attr_reader :value

      # Location of the +::+ operator
      #
      # @example
      #  A::B = 1
      #   ~~
      #
      #  ::A = 1
      #  ~~
      #
      # +None+ if the constant is defined in the current scope
      #
      # @return [Loc, nil]
      attr_reader :double_colon_l

      # Location of the constant name
      #
      # @example
      #  A::CONST = 1
      #     ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the +=+ operator
      #
      # @example
      #  A = 1
      #    ~
      #
      # +None+ if constant assignment is a part of the multi-assignment.
      # In such case +=+ belongs to a +Masgn+ node
      #
      # @return [Loc, nil]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  A = 1
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents leading +::+ part of the constant access/assignment that is used to get/set on a global namespace.
    class Cbase < Node
      # Location of the full expression
      #
      # @example
      #  ::A
      #  ~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a class definition (using a +class+ keyword, +Class.new+ is just a method call)
    class Class < Node
      # Name of the class, +String("Foo")+ for +class Foo; end+
      #
      # @return [Node]
      attr_reader :name

      # Superclass. Can be an expression in cases like +class A < (obj.foo + 1); end+
      #
      # +None+ if no explicit superclass given (i.e. +class Foo; end+)
      #
      # @return [Node, nil]
      attr_reader :superclass

      # Body of the method, +None+ if there's no body.
      #
      # @return [Node, nil]
      attr_reader :body

      # Location of the +class+ keyword.
      #
      # @example
      #  class Foo; end
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +<+ operator
      #
      # @example
      #  class A < B; end
      #          ~
      #
      # +None+ if there's no explicit superclass given.
      #
      # @return [Loc, nil]
      attr_reader :operator_l

      # Location of the +end+ keyword.
      #
      # @example
      #  class Foo; end
      #             ~~~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  class Foo; end
      #  ~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a +Complex+ literal (that returns an +Complex+ number)
    class Complex < Node
      # Value of the complex literal, returned as a +String+, +String("1i")+ for +1i+
      #
      # @return [String]
      attr_reader :value

      # Location of the +-+ (but not +++) operator. +++ is a part of the literal:
      # 1. ++1i+ is +String("+1i")+ with +operator = None+
      # 2. +-1i+ is +String("1i")+ with +operator = String("-")+
      #
      # @example
      #  -1i
      #  ~
      #
      #
      # @return [Loc, nil]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  -1i
      #  ~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents constant access (i.e. +Foo::Bar+)
    class Const < Node
      # Scope where the constant is taken from:
      # 1. +Some(Const("A"))+ for +A::B+
      # 2. +None+ if it's taken from the current scope (i.e. +A+)
      # 3. +Some(Cbase)+ if it's taken from the global scope (i.e. +::A+)
      #
      # @return [Node, nil]
      attr_reader :scope

      # Name of the constant, +String("Foo")+ for +Foo+
      #
      # @return [String]
      attr_reader :name

      # Location of the +::+ operator. +None+ if constant is taken from the current scope.
      #
      # @example
      #  A::B
      #   ~~
      #
      #
      # @return [Loc, nil]
      attr_reader :double_colon_l

      # Location of the constant name
      #
      # @example
      #  Foo::Bar
      #       ~~~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the full expression
      #
      # @example
      #  Foo::Bar
      #  ~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Const pattern used in pattern matching (e.g. +in A(1, 2)+)
    class ConstPattern < Node
      # Constant that is used, +Const("Foo")+ for +in For(42)+
      #
      # @return [Node]
      attr_reader :const

      # Inner part of the constant pattern
      #
      # +ArrayPattern(vec![ Int("1") ])+ for +Foo(1)+
      #
      # @return [Node]
      attr_reader :pattern

      # Location of the open parenthesis
      #
      # @example
      #  case 1; in Foo(42); end
      #                ~
      #
      #
      # @return [Loc]
      attr_reader :begin_l

      # Location of the closing parenthesis
      #
      # @example
      #  case 1; in Foo(42); end
      #                   ~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  case 1; in Foo(42); end
      #             ~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents conditional method call using +&.+ operator
    class CSend < Node
      # Receiver of the method call, +Int("1")+ for +1&.foo+
      #
      # @return [Node]
      attr_reader :recv

      # Name of the method, +String("foo")+ for +1&.foo+
      #
      # @return [String]
      attr_reader :method_name

      # List of arguments
      #
      # @example
      #  foo&.bar(42)
      #  # and also setters like
      #  foo&.bar = 42
      #
      #
      # @return [::Array<Node>]
      attr_reader :args

      # Location of the +&.+ operator
      #
      # @example
      #  foo&.bar
      #     ~~
      #
      #
      # @return [Loc]
      attr_reader :dot_l

      # Location of the method name
      #
      # @example
      #  foo&.bar(42)
      #       ~~~
      #
      # +None+ in a very special case when method call is implicit (i.e. +foo&.()+)
      #
      # @return [Loc, nil]
      attr_reader :selector_l

      # Location of the open parenthesis
      #
      # @example
      #  foo&.bar(42)
      #          ~
      #
      # +None+ if there are no parentheses
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the closing parenthesis
      #
      # @example
      #  foo&.bar(42)
      #             ~
      #
      # +None+ if there are no parentheses
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the operator if +CSend+ is a part of assignment like
      #
      # @example
      #  foo&.bar = 1
      #           ~
      #
      # +None+ for a regular call.
      #
      # @return [Loc, nil]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  foo&.bar(42)
      #  ~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents access to class variable (i.e. +@@var+)
    class Cvar < Node
      # Name of the class variable, +String("@@foo")+ for +@@foo+
      #
      # @return [String]
      attr_reader :name

      # Location of the full expression
      #
      # @example
      #  @@foo
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents class variable assignment (i.e. +@@var = 42+)
    class Cvasgn < Node
      # Name of the class variable, +String("@@foo")+ for +@@foo = 1+
      #
      # @return [String]
      attr_reader :name

      # Value that is assigned to class variable, +Int("1")+ for +@@foo = 1+
      #
      # @return [Node, nil]
      attr_reader :value

      # Location of the class variable name
      #
      # @example
      #  @@foo = 1
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the +=+ operator
      #
      # @example
      #  @@foo = 1
      #        ~
      #
      #
      # @return [Loc, nil]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  @@foo = 1
      #  ~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents method definition using +def+ keyword (not on a singleton, see +Defs+ node).
    class Def < Node
      # Name of the method, +String("foo")+ for +def foo; end+
      #
      # @return [String]
      attr_reader :name

      # Arguments of a method, +None+ if there's no arguments.
      #
      # All information about parentheses around arguments is stored in this node.
      #
      # @return [Node, nil]
      attr_reader :args

      # Body of a method, +None+ if there's no body.
      #
      # @return [Node, nil]
      attr_reader :body

      # Location of the +def+ keyword.
      #
      # @example
      #  def foo; end
      #  ~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the method name.
      #
      # @example
      #  def foo; end
      #      ~~~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the +end+ keyword.
      #
      # @example
      #  def foo; end
      #           ~~~
      #
      # +None+ for endless method definition
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the +=+ operator for endless method definition
      #
      # @example
      #  def m() = 1
      #          ~
      #
      # +None+ for regular method definition
      #
      # @return [Loc, nil]
      attr_reader :assignment_l

      # Location of the full expression
      #
      # @example
      #  def m(a); foo; end
      #  ~~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a +defined?(foo)+ expression
    class Defined < Node
      # Value given to +defined?+
      #
      # @return [Node]
      attr_reader :value

      # Location of the +defined?+ keyword
      #
      # @example
      #  defined?(foo)
      #  ~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the open parenthesis
      #
      # @example
      #  defined?(foo)
      #          ~
      #
      # +None+ if there are no parentheses
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the closing parenthesis
      #
      # @example
      #  defined?(foo)
      #              ~
      #
      # +None+ if there are no parentheses
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  defined?(foo)
      #  ~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a singleton method definition (i.e. +def self.foo; end+)
    class Defs < Node
      # Definee of a method definition, +Lvar("x")+ for +def x.foo; end+
      #
      # @return [Node]
      attr_reader :definee

      # Name of the method, +String("foo")+ for +def x.foo; end+
      #
      # @return [String]
      attr_reader :name

      # Arguments of a method, +None+ if there's no arguments.
      #
      # All information about parentheses around arguments is stored in this node.
      #
      # @return [Node, nil]
      attr_reader :args

      # Body of the method, +None+ if there's no body.
      #
      # @return [Node, nil]
      attr_reader :body

      # Location of the +def+ keyword
      #
      # @example
      #  def self.foo; end
      #  ~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +.+
      #
      # @example
      #  def self.foo; end
      #          ~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the method name
      #
      # @example
      #  def self.foo; end
      #           ~~~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the +=+ operator for endless method definition
      #
      # @example
      #  def self.foo() = 42
      #                 ~
      #
      # +None+ for regular method definition
      #
      # @return [Loc, nil]
      attr_reader :assignment_l

      # Location of the +end+ keyword
      #
      # @example
      #  def self.foo; end
      #                ~~~
      #
      # +None+ for endless method definition
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  def self.foo; end
      #  ~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a string with interpolation (i.e. +"#{foo}"+)
    class Dstr < Node
      # A list of string parts (static literals and interpolated expressions)
      #
      # @return [::Array<Node>]
      attr_reader :parts

      # Location of the string begin
      #
      # @example
      #  "#{foo}"
      #  ~
      #
      #  %Q{#{foo}}
      #  ~~~
      #
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the string end
      #
      # @example
      #  "#{foo}"
      #         ~
      #
      #  %Q{#{foo}}
      #           ~
      #
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  "#{foo}"
      #  ~~~~~~~~
      #
      #  %Q{#{foo}}
      #  ~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a symbol with interpolation (i.e. +:"#{foo}"+)
    class Dsym < Node
      # A list of symbol parts (static literals and interpolated expressions)
      #
      # @return [::Array<Node>]
      attr_reader :parts

      # Location of the symbol begin
      #
      # @example
      #  :"#{foo}"
      #  ~~
      #
      # +None+ if +Dsym+ is a part of the interpolated symbol array:
      #
      # @example
      #  %I[#{bar}]
      #
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the symbol begin
      #
      # @example
      #  :"#{foo}"
      #          ~
      #
      # +None+ if +Dsym+ is a part of the interpolated symbol array:
      #
      # @example
      #  %I[#{bar}]
      #
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  :"#{foo}"
      #  ~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents exclusive flip-flop (i.e. in +if foo...bar; end+)
    class EFlipFlop < Node
      # Left part of the flip-flop. +None+ if based on a range without begin (+...bar+)
      #
      # @return [Node, nil]
      attr_reader :left

      # Right part of the flip-flop. +None+ if based on a range without end (+foo...+)
      #
      # @return [Node, nil]
      attr_reader :right

      # Location of the +...+ operator
      #
      # @example
      #  if foo...bar; end
      #        ~~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  if foo...bar; end
      #     ~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a special empty else that is a part of the pattern matching.
    #
    # Usually empty else (e.g. part of the +if+ statement) doesn't mean anything,
    # however in pattern matching it prevents raising a +NoPatternError+.
    #
    # Throwing away this +else+ may affect your code.
    class EmptyElse < Node
      # Location of the +else+ keyword
      #
      # @example
      #  case foo; in 1; else; end
      #                  ~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a special +__ENCODING__+ keyword
    class Encoding < Node
      # Location of the +__ENCODING__+ keyword
      #
      # @example
      #  __ENCODING__
      #  ~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a block of code with +ensure+ (i.e. +begin; ensure; end+)
    class Ensure < Node
      # Block of code that is wrapped into +ensure+
      # **Note**: that's the body of the +ensure+ block
      #
      # +Int("1")+ for +begin; 1; ensure; 2; end+
      #
      # @return [Node, nil]
      attr_reader :body

      # Body of the +ensure+ block
      #
      # +Int("2")+ for +begin; 1; ensure; 2; end+
      #
      # @return [Node, nil]
      attr_reader :ensure

      # Location of the +ensure+ keyword
      #
      # @example
      #  begin; ensure; end
      #         ~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the full expression
      #
      # @example
      #  begin; 1; rescue; 2; else; 3; ensure; 4; end
      #         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      #
      # **Note**: begin/end belong to +KwBegin+ node.
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents range literal with excluded +end+ (i.e. +1...3+)
    class Erange < Node
      # Begin of the range, +None+ if range has no begin (i.e +...42+)
      #
      # @return [Node, nil]
      attr_reader :left

      # End of the range, +None+ if range has no end (i.e +42...+)
      #
      # @return [Node, nil]
      attr_reader :right

      # Location of the +...+ operator
      #
      # @example
      #  1...3
      #   ~~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  1...3
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a +false+ literal
    class False < Node
      # Location of the +false+ literal
      #
      # @example
      #  false
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a special +__FILE__+ literal
    class File < Node
      # Location of the +__FILE__+ literal
      #
      # @example
      #  __FILE__
      #  ~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a find pattern using in pattern matching (i.e. +in [*x, 1 => a, *y]+)
    #
    # It's different from +ArrayPattern+/+ConstPattern+ because it supports multiple wildcard pattern
    class FindPattern < Node
      # Inner part of the find pattern
      #
      # @return [::Array<Node>]
      attr_reader :elements

      # Location of the begin
      #
      # @example
      #  case foo; in [*x, 1 => a, *y]; end
      #               ~
      #
      # +None+ if there are no brackets/parentheses
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the end
      #
      # @example
      #  case foo; in [*x, 1 => a, *y]; end
      #                              ~
      #
      # +None+ if there are no brackets/parentheses
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  case foo; in [*x, 1 => a, *y]; end
      #               ~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a float literal (i.e. +42.5+)
    class Float < Node
      # String value of the literal, +String("42.5")+ for +42.5+
      #
      # @return [String]
      attr_reader :value

      # Location of unary +-+ (but not +++)
      #
      # @example
      #  -42.5
      #  ~
      #
      #
      # @return [Loc, nil]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  -42.5
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a +for+ loop
    class For < Node
      # Variable that is used in loop, +Lvasgn("a")+ in +for a in b; end+
      #
      # @return [Node]
      attr_reader :iterator

      # Collection that is for iteration. +Lvar("b")+ in +for a in b; end+
      #
      # @return [Node]
      attr_reader :iteratee

      # Body of the loop. +None+ if there's no body
      #
      # @return [Node, nil]
      attr_reader :body

      # Location of the +for+ keyword
      #
      # @example
      #  for a in b; end
      #  ~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +in+ keyword
      #
      # @example
      #  for a in b; end
      #        ~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the +do+ keyword
      #
      # @example
      #  for a in b do; end
      #             ~~
      #
      # **Note**: this +do+ is optional, and so +begin_l+ can be +None+.
      #
      # @return [Loc]
      attr_reader :begin_l

      # Location of the +end+ keyword
      #
      # @example
      #  for a in b; end
      #              ~~~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  for a in b; end
      #  ~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a special +...+ argument that forwards positional/keyword/block arguments.
    class ForwardArg < Node
      # Location of the +...+
      #
      # @example
      #  def m(...); end
      #        ~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a +...+ operator that contains forwarded argument (see +ForwardArg+)
    class ForwardedArgs < Node
      # Location of the +...+
      #
      # @example
      #  def m(...); foo(...); end
      #                  ~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents access to global variable (i.e. +$foo+)
    class Gvar < Node
      # Name of the global variable, +String("$foo")+ for +$foo+
      #
      # @return [String]
      attr_reader :name

      # Location of the full expression
      #
      # @example
      #  $foo
      #  ~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents global variable assignment (i.e. +$foo = 42+)
    class Gvasgn < Node
      # Name of the global variable, +String("$foo")+ for +$foo+
      #
      # @return [String]
      attr_reader :name

      # Value that is assigned to global variable, +Int("42")+ for +$foo = 42+
      #
      # +None+ if global variable assignment is a part of the multi-assignment.
      # In such case +value+ is a part of the +Masgn+ node.
      #
      # @return [Node, nil]
      attr_reader :value

      # Location of the global variable name
      #
      # @example
      #  $foo = 42
      #  ~~~~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the +=+ operator
      #
      # @example
      #  $foo = 42
      #       ~
      #
      # +None+ if global variable assignment is a part of the multi-assignment.
      # In such case +=+ operator belongs to the +Masgn+ node.
      #
      # @return [Loc, nil]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  $foo = 42
      #  ~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a hash literal (i.e. +{ foo: 42 }+)
    class Hash < Node
      # A list of key-value pairs
      #
      # @return [::Array<Node>]
      attr_reader :pairs

      # Location of the open parenthesis
      #
      # @example
      #  { a: 1 }
      #  ~
      #
      # +None+ if hash literal is implicit, e.g. +foo(key: "value")+
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the closing parenthesis
      #
      # @example
      #  { a: 1 }
      #         ~
      #
      # +None+ if hash literal is implicit, e.g. +foo(key: "value")+
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  { a: 1 }
      #  ~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a hash pattern used in pattern matching (i.e. +in { a: 1 }+)
    class HashPattern < Node
      # A list of inner patterns
      #
      # @return [::Array<Node>]
      attr_reader :elements

      # Location of the open parenthesis
      #
      # @example
      #  case foo; in { a: 1 }; end
      #               ~
      #
      # +None+ if there are no parentheses
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the open parenthesis
      #
      # @example
      #  case foo; in { a: 1 }; end
      #                      ~
      #
      # +None+ if there are no parentheses
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  case foo; in { a: 1 }; end
      #               ~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a here-document literal (both with and without interpolation)
    #
    # It's similar to +Dstr+ in terms of abstract syntax tree, but has different source maps.
    class Heredoc < Node
      # A list of string parts (static literals and interpolated expressions)
      #
      # @return [::Array<Node>]
      attr_reader :parts

      # Location of the here-document body
      #
      # @example
      #  <<-HERE\n  a\n   #{42}\nHERE
      #  ~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :heredoc_body_l

      # Location of the here-document end
      #
      # @example
      #  <<-HERE\n  a\n   #{42}\nHERE
      #                          ~~~~
      #
      #
      # @return [Loc]
      attr_reader :heredoc_end_l

      # Location of the here-document identifier
      #
      # @example
      #  <<-HERE\n  a\n   #{42}\nHERE
      #  ~~~~~~~
      #
      # **Note**: This is the only node (with +XHeredoc+) that has +expression_l+ smaller that all other sub-locations merged.
      # The reason for that is that it's possible to add more code after here-document ID:
      #
      # @example
      #  <<-HERE + "rest"
      #  content
      #  HERE
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an +if+ statement (i.e. +if foo; bar; else; baz; end+)
    class If < Node
      # Condition given to the +if+ statement, +Lvar("a")+ for +if a; b; else; c; end+
      #
      # @return [Node]
      attr_reader :cond

      # True-branch of the +if+ statement, +Lvar("b")+ for +if a; b; else; c; end+
      #
      # @return [Node, nil]
      attr_reader :if_true

      # False-branch of the +if+ statement, +Lvar("c")+ for +if a; b; else; c; end+
      #
      # @return [Node, nil]
      attr_reader :if_false

      # Location of the +if+ keyword
      #
      # @example
      #  if foo; end
      #  ~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +then+ keyword
      #
      # @example
      #  if foo then; end
      #         ~~~~
      #
      # +None+ if +then+ keyword is omitted
      #
      # @return [Loc]
      attr_reader :begin_l

      # Location of the +else+ keyword
      #
      # @example
      #  if foo; else; end
      #          ~~~~
      #
      # +None+ if there's no +else+ branch
      #
      # @return [Loc, nil]
      attr_reader :else_l

      # Location of the +end+ keyword
      #
      # @example
      #  if foo; end
      #          ~~~
      #
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  if a then; b; else; c end
      #  ~~~~~~~~~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an +if+ guard used in pattern matching (i.e. +case foo; in pattern if guard; end+)
    class IfGuard < Node
      # Condition of the guard, +Lvar("foo")+ in +in pattern if guard+
      #
      # @return [Node]
      attr_reader :cond

      # Location of the +if+ keyword
      #
      # @example
      #  case foo; in pattern if cond; end
      #                       ~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the full expression
      #
      # @example
      #  case foo; in pattern if cond; end
      #                       ~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents inclusive flip-flop (i.e. in +if foo..bar; end+)
    class IFlipFlop < Node
      # Left part of the flip-flop. +None+ if based on a range without begin (+..bar+)
      #
      # @return [Node, nil]
      attr_reader :left

      # Right part of the flip-flop. +None+ if based on a range without end (+foo..+)
      #
      # @return [Node, nil]
      attr_reader :right

      # Location of the +..+ operator
      #
      # @example
      #  if foo..bar; end
      #        ~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  if foo..bar; end
      #     ~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an +if+/+unless+ modifier (i.e. +stmt if cond+)
    class IfMod < Node
      # Condition of the modifier
      #
      # @return [Node]
      attr_reader :cond

      # True-branch of the modifier.
      #
      # Always set for +if+ modifier.
      # Always +None+ for +unless+ modifier.
      #
      # @return [Node, nil]
      attr_reader :if_true

      # False-branch of the modifier.
      #
      # Always set for +unless+ modifier.
      # Always +None+ for +if+ modifier.
      #
      # @return [Node, nil]
      attr_reader :if_false

      # Location of the +if+/+unless+ keyword
      #
      # @example
      #  stmt if cond
      #       ~~
      #
      #  stmt unless cond
      #       ~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the full expression
      #
      # @example
      #  stmt if cond
      #  ~~~~~~~~~~~~
      #
      #  stmt unless cond
      #  ~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents ternary +if+ statement (i.e. +cond ? if_true : if_false+)
    class IfTernary < Node
      # Condition of the +if+ statement
      #
      # @return [Node]
      attr_reader :cond

      # True-branch
      #
      # @return [Node]
      attr_reader :if_true

      # True-branch
      #
      # @return [Node]
      attr_reader :if_false

      # Location of the +?+ operator
      #
      # @example
      #  cond ? if_true : if_false
      #       ~
      #
      #
      # @return [Loc]
      attr_reader :question_l

      # Location of the +:+ operator
      #
      # @example
      #  cond ? if_true : if_false
      #                 ~
      #
      #
      # @return [Loc]
      attr_reader :colon_l

      # Location of the full expression
      #
      # @example
      #  cond ? if_true : if_false
      #  ~~~~~~~~~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents indexing operation (i.e. +foo[1,2,3]+)
    class Index < Node
      # Receiver of indexing
      #
      # @return [Node]
      attr_reader :recv

      # A list of indexes
      #
      # @return [::Array<Node>]
      attr_reader :indexes

      # Location of open bracket
      #
      # @example
      #  foo[1, 2, 3]
      #     ~
      #
      #
      # @return [Loc]
      attr_reader :begin_l

      # Location of closing bracket
      #
      # @example
      #  foo[1, 2, 3]
      #             ~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  foo[1, 2, 3]
      #  ~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents assignment using indexing operation (i.e. +foo[1, 2, 3] = bar+)
    class IndexAsgn < Node
      # Receiver of the indexing
      #
      # @return [Node]
      attr_reader :recv

      # A list of indexes
      #
      # @return [::Array<Node>]
      attr_reader :indexes

      # Value that is assigned
      #
      # +None+ if assignment is a part of the multi-assignment.
      # In such case +value+ belongs to +Masgn+ node.
      #
      # @return [Node, nil]
      attr_reader :value

      # Location of open bracket
      #
      # @example
      #  foo[1, 2, 3] = bar
      #     ~
      #
      #
      # @return [Loc]
      attr_reader :begin_l

      # Location of closing bracket
      #
      # @example
      #  foo[1, 2, 3] = bar
      #             ~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the +=+ operator
      #
      # @example
      #  foo[1, 2, 3] = bar
      #               ~
      #
      # +None+ if assignment is a part of the multi-assignment.
      # In such case operator +=+ belongs to +Masgn+ node.
      #
      # @return [Loc, nil]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  foo[1, 2, 3] = bar
      #  ~~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an +in pattern+ branch of the pattern matching
    class InPattern < Node
      # Value that is used for matching
      #
      # @return [Node]
      attr_reader :pattern

      # Guard that is used for matching
      #
      # Optional, so can be +None+
      #
      # @return [Node, nil]
      attr_reader :guard

      # Body of the branch that is invoked if value matches pattern
      #
      # @return [Node, nil]
      attr_reader :body

      # Location of the +in+ keyword
      #
      # @example
      #  case value; in pattern; end
      #              ~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +then+ keyword
      #
      # @example
      #  case value; in pattern then; end
      #                         ~~~~
      #
      #
      # @return [Loc]
      attr_reader :begin_l

      # Location of the full expression
      #
      # @example
      #  case value; in pattern then; 42; end
      #              ~~~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an integer literal (i.e. +42+)
    class Int < Node
      # String value of the literal, +String("42")+ for +42+
      #
      # @return [String]
      attr_reader :value

      # Location of unary +-+ (but not +++)
      #
      # @example
      #  -42
      #  ~
      #
      #
      # @return [Loc, nil]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  -42
      #  ~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents inclusive range (i.e. +2..4+)
    class Irange < Node
      # Begin of the range, +None+ if range has no +begin+ (i.e. +..4+)
      #
      # @return [Node, nil]
      attr_reader :left

      # End of the range, +None+ if range has no +end+ (i.e. +2..+)
      #
      # @return [Node, nil]
      attr_reader :right

      # Location of the +..+ operator
      #
      # @example
      #  2..4
      #   ~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  2..4
      #  ~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents access to instance variable (i.e. +@foo+)
    class Ivar < Node
      # Name of the instance variable, +String("@foo")+ in +@foo+
      #
      # @return [String]
      attr_reader :name

      # Location of the full expression
      #
      # @example
      #  @foo
      #  ~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents instance variable assignment (i.e +@foo = 42+)
    class Ivasgn < Node
      # Name of the instance variable, +String("@foo")+ in +@foo = 42+
      #
      # @return [String]
      attr_reader :name

      # Value that is assigned to instance variable.
      #
      # +None+ if instance variable assignment is a part of the multi-assignment.
      # In such case +value+ is a part of the +Masgn+ node.
      #
      # @return [Node, nil]
      attr_reader :value

      # Location of the instance variable name.
      #
      # @example
      #  @foo = 1
      #  ~~~~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the +=+ operator.
      #
      # @example
      #  @foo = 1
      #       ~
      #
      # +None+ if instance variable assignment is a part of the multi-assignment.
      # In such case +value+ is a part of the +Masgn+ node.
      #
      # @return [Loc, nil]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  @foo = 42
      #  ~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents required keyword argument (i.e. +foo+ in +def m(foo:); end+)
    class Kwarg < Node
      # Name of the keyword argument
      #
      # @return [String]
      attr_reader :name

      # Location of the name
      #
      # @example
      #  def foo(bar:); end
      #          ~~~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the full expression
      #
      # @example
      #  def foo(bar:); end
      #          ~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents kwargs that are given to a method call, super or yield (i.e. +foo(bar: 1)+)
    class Kwargs < Node
      # A list of key-value pairs
      #
      # @return [::Array<Node>]
      attr_reader :pairs

      # Location of the full expression
      #
      # @example
      #  foo(bar: 1)
      #      ~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an explicit +begin; end+ block.
    #
    # The reason why it's different is that
    #
    # @example
    #  begin; foo; end while cond
    #
    # is a post-while loop (same with post-until loop)
    class KwBegin < Node
      # A list of statements
      #
      # @return [::Array<Node>]
      attr_reader :statements

      # Location of the +begin+ keyword
      #
      # @example
      #  begin; foo; end
      #  ~~~~~
      #
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the +end+ keyword
      #
      # @example
      #  begin; foo; end
      #              ~~~
      #
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  begin; foo; bar
      #  ~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an special argument that rejects all keyword arguments (i.e. +def m(**nil); end+)
    class Kwnilarg < Node
      # Location of the +nil+
      #
      # @example
      #  def m(**nil); end
      #          ~~~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the +nil+
      #
      # @example
      #  def m(**nil); end
      #        ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an optional keyword argument (i.e. +foo+ in +def m(foo: 42); end+)
    class Kwoptarg < Node
      # Name of the optional keyword argument
      #
      # @return [String]
      attr_reader :name

      # Default value of the optional keyword argument
      #
      # @return [Node]
      attr_reader :default

      # Location of the argument name
      #
      # @example
      #  def m(foo: 1); end
      #        ~~~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the argument name
      #
      # @example
      #  def m(foo: 1); end
      #        ~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a keyword rest argument (i.e. +foo+ in +def m(**foo); end+)
    class Kwrestarg < Node
      # Name of the keyword rest argument, +String("foo")+ in +def m(**foo); end+.
      #
      # +None+ if argument has no name (+def m(**); end+)
      #
      # @return [String, nil]
      attr_reader :name

      # Location of the +**+ operator
      #
      # @example
      #  def m(**foo); end
      #        ~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the argument name
      #
      # @example
      #  def m(**foo); end
      #          ~~~
      #
      # +None+ if argument has no name (+def m(**); end+)
      #
      # @return [Loc, nil]
      attr_reader :name_l

      # Location of the full expression
      #
      # @example
      #  def m(**foo); end
      #        ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a keyword arguments splat (i.e. +**bar+ in a call like +foo(**bar)+)
    class Kwsplat < Node
      # Value that is converted into a +Hash+ using +**+
      #
      # @return [Node]
      attr_reader :value

      # Location of the +**+ operator
      #
      # @example
      #  foo(**bar)
      #      ~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  foo(**bar)
      #      ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a lambda call using +->+ (i.e. +-> {}+)
    #
    # Note that +Lambda+ is a part of the +Block+, not other way around.
    class Lambda < Node
      # Location of the +->+
      #
      # @example
      #  -> {}
      #  ~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a special +__LINE__+ literal
    class Line < Node
      # Location of the +__LINE__+ literal
      #
      # @example
      #  __LINE__
      #  ~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents access to a local variable (i.e. +foo+)
    #
    # Parser knows that it's a local variable because:
    # 1. there was an assignment to this variable **before** accessing it
    # 2. it's an argument of the current method / block
    # 3. it's been implicitly declared by +MatchWithLvasgn+ node
    #
    # Otherwise it's a method call (see +Send+)
    class Lvar < Node
      # Name of the local variable
      #
      # @return [String]
      attr_reader :name

      # Location of the local variable
      #
      # @example
      #  foo
      #  ~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents local variable assignment (i.e. +foo = 42+)
    class Lvasgn < Node
      # Name of the local variable
      #
      # @return [String]
      attr_reader :name

      # Value that is assigned to a local variable
      #
      # @return [Node, nil]
      attr_reader :value

      # Location of the local variable name
      #
      # @example
      #  foo = 42
      #  ~~~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the +=+ operator
      #
      # @example
      #  foo = 42
      #      ~
      #
      # +None+ if local variable assignment is a part of the multi-assignment.
      # In such case +value+ is a part of the +Masgn+ node.
      #
      # @return [Loc, nil]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  foo = 42
      #  ~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents mass-assignment (i.e. +foo, bar = 1, 2+)
    class Masgn < Node
      # Left hand statement of the assignment
      #
      # @return [Node]
      attr_reader :lhs

      # Left hand statement of the assignment
      #
      # @return [Node]
      attr_reader :rhs

      # Location of the +=+ operator
      #
      # @example
      #  foo, bar = 1, 2
      #           ~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  foo, bar = 1, 2
      #  ~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents pattern matching using one of the given patterns (i.e. +foo in 1 | 2+)
    class MatchAlt < Node
      # Left pattern
      #
      # @return [Node]
      attr_reader :lhs

      # Right pattern
      #
      # @return [Node]
      attr_reader :rhs

      # Location of the +|+ operator
      #
      # @example
      #  foo in 1 | 2
      #           ~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  foo in 1 | 2
      #         ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents matching with renaming into specified local variable (i.e. +case 1; in Integer => a; end+)
    class MatchAs < Node
      # Pattern that is used for matching
      #
      # @return [Node]
      attr_reader :value

      # Variable that is assigned if matched (see +MatchVar+ node)
      #
      # @return [Node]
      attr_reader :as

      # Location of the +=>+ operator
      #
      # @example
      #  case 1; in Integer => a; end
      #                     ~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  case 1; in Integer => a; end
      #             ~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents implicit matching using +if /regex/+
    #
    # @example
    #  if /.*/
    #  puts 'true'
    #  else
    #  puts 'false'
    #  end
    #
    # Prints "false".
    #
    # Under the hood this construction matches regex against +$_+, so the following works:
    #
    # @example
    #  $_ = 'match_me'
    #  if /match_me/
    #  puts 'true'
    #  else
    #  puts 'false'
    #  end
    #
    # this code prints "true".
    class MatchCurrentLine < Node
      # Given regex
      #
      # @return [Node]
      attr_reader :re

      # Location of the regex
      #
      # @example
      #  if /re/; end
      #     ~~~~
      #
      # Technically this location is redundant, but keeping it is the only way to
      # have the same interface for all nodes.
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents empty hash pattern that is used in pattern matching (i.e. +in **nil+)
    class MatchNilPattern < Node
      # Location of the +**+ operator
      #
      # @example
      #  in **nil
      #     ~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the name
      #
      # @example
      #  in **nil
      #       ~~~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the full expression
      #
      # @example
      #  in **nil
      #     ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a one-line pattern matching that can throw an error (i.e. +foo => pattern+)
    class MatchPattern < Node
      # Value that is used for matching
      #
      # @return [Node]
      attr_reader :value

      # Pattern that is used for matching
      #
      # @return [Node]
      attr_reader :pattern

      # Location of the +=>+ operator
      #
      # @example
      #  foo => pattern
      #      ~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  foo => pattern
      #  ~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a one-line pattern matching that never throws but returns true/false (i.e. +foo in pattern+)
    class MatchPatternP < Node
      # Value that is used for matching
      #
      # @return [Node]
      attr_reader :value

      # Pattern that is used for matching
      #
      # @return [Node]
      attr_reader :pattern

      # Location of the +in+ operator
      #
      # @example
      #  foo in pattern
      #      ~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  foo in pattern
      #  ~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a wildcard pattern used in pattern matching (i.e. +in *foo+)
    class MatchRest < Node
      # Name of the variable name
      #
      # +None+ if there's no name (i.e. +in *+)
      #
      # @return [Node, nil]
      attr_reader :name

      # Location of the +*+ operator
      #
      # @example
      #  case foo; in *bar; end
      #               ~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the +*+ operator
      #
      # @example
      #  case foo; in *bar; end
      #               ~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents matching with assignment into a local variable (i.e. +pattern => var+)
    class MatchVar < Node
      # Name of the variable that is assigned if matching succeeds
      #
      # @return [String]
      attr_reader :name

      # Location of the name
      #
      # @example
      #  case foo; in pattern => bar; end
      #                          ~~~
      #
      # **Note** it can also be produced by a hash pattern
      #
      # @example
      #  case foo; in { a: }; end
      #                 ~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the full expression
      #
      # @example
      #  case foo; in pattern => bar; end
      #                          ~~~
      #
      # **Note** it can also be produced by a hash pattern
      #
      # @example
      #  case foo; in { a: }; end
      #                 ~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents matching a regex that produces local variables (i.e. +/(?<match>bar)/ =~ 'bar'+)
    #
    # Each named group in regex declares a local variable.
    class MatchWithLvasgn < Node
      # Regex that is used for matching
      #
      # @return [Node]
      attr_reader :re

      # Value that is used for matching
      #
      # @return [Node]
      attr_reader :value

      # Location of the +=~+ operatir
      #
      # @example
      #  /(?<match>bar)/ =~ 'bar'
      #                  ~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  /(?<match>bar)/ =~ 'bar'
      #  ~~~~~~~~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents left hand statement of the mass-assignment (i.e. +foo, bar+ in +foo, bar = 1, 2+)
    class Mlhs < Node
      # A list of items that are assigned
      #
      # @return [::Array<Node>]
      attr_reader :items

      # Location of the open parenthesis
      #
      # @example
      #  (a, b) = 1, 2
      #  ~
      #
      # +None+ if there are no parentheses
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the closing parenthesis
      #
      # @example
      #  (a, b) = 1, 2
      #       ~
      #
      # +None+ if there are no parentheses
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  (a, b) = 1, 2
      #  ~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents module declaration using +module+ keyword
    class Module < Node
      # Name of the module
      #
      # @return [Node]
      attr_reader :name

      # Body of the module
      #
      # +None+ if module has no body
      #
      # @return [Node, nil]
      attr_reader :body

      # Location of the +module+ keyword
      #
      # @example
      #  module M; end
      #  ~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +end+ keyword
      #
      # @example
      #  module M; end
      #            ~~~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  module M; end
      #  ~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents +next+ keyword
    class Next < Node
      # Arguments given to +next+
      #
      # @return [::Array<Node>]
      attr_reader :args

      # Location of the +next+ keyword
      #
      # @example
      #  next 42
      #  ~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the full expression
      #
      # @example
      #  next(42)
      #  ~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents +nil+ literal
    class Nil < Node
      # Location of the +nil+ keyword
      #
      # @example
      #  nil
      #  ~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents numeric global variable (e.g. +$1+)
    class NthRef < Node
      # Name of the variable, +String("1")+ for +$1+
      #
      # @return [String]
      attr_reader :name

      # Location of the full expression
      #
      # @example
      #  $1
      #  ~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a block that takes numbered parameters (i.e. +proc { _1 }+)
    class Numblock < Node
      # Method call that takes a block
      #
      # @return [Node]
      attr_reader :call

      # Number of parameters that block takes
      #
      # @return [Integer]
      attr_reader :numargs

      # Block body
      #
      # @return [Node]
      attr_reader :body

      # Location of the open brace
      #
      # @example
      #  proc { _1 }
      #       ~
      #
      #
      # @return [Loc]
      attr_reader :begin_l

      # Location of the closing brace
      #
      # @example
      #  proc { _1 }
      #            ~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the open brace
      #
      # @example
      #  proc { _1 }
      #  ~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an operation with assignment (e.g. +a += 1+)
    class OpAsgn < Node
      # Left hand statement of the assignment
      #
      # @return [Node]
      attr_reader :recv

      # Operator, can be one of:
      # 1. ++=+
      # 2. +-=+
      # 3. +*=+
      # 4. +/=+
      # 5. +|=+
      # 6. +&=+
      # 7. +>>=+
      # 8. +<<=+
      # 9. +%=+
      # 10. +^=+
      # 11. +**=+
      #
      # @return [String]
      attr_reader :operator

      # Right hand statement of the assignment
      #
      # @return [Node]
      attr_reader :value

      # Location of the operator
      #
      # @example
      #  a.b <<= c
      #      ~~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the operator
      #
      # @example
      #  a.b <<= c
      #  ~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents optional positional argument (i.e. +foo+ in +m(foo = 1)+)
    class Optarg < Node
      # Name of the argument
      #
      # @return [String]
      attr_reader :name

      # Default value of the argument
      #
      # @return [Node]
      attr_reader :default

      # Location of the argument name
      #
      # @example
      #  def m(foo = 1); end
      #        ~~~
      #
      #
      # @return [Loc]
      attr_reader :name_l

      # Location of the +=+ operator
      #
      # @example
      #  def m(foo = 1); end
      #            ~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  def m(foo = 1); end
      #        ~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents +foo || bar+ (or +foo or bar+) statement.
    class Or < Node
      # Left hand statement
      #
      # @return [Node]
      attr_reader :lhs

      # Right hand statement
      #
      # @return [Node]
      attr_reader :rhs

      # Location of the +||+/+or+ operator
      #
      # @example
      #  foo || bar
      #      ~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  foo || bar
      #  ~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents +lhs ||= rhs+ assignment
    class OrAsgn < Node
      # Left hand statement
      #
      # @return [Node]
      attr_reader :recv

      # Right hand statement
      #
      # @return [Node]
      attr_reader :value

      # Location of the +||=+ operator
      #
      # @example
      #  foo ||= bar
      #      ~~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  foo ||= bar
      #  ~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a key/value pair (e.g. a part of the +Hash+ node)
    class Pair < Node
      # Key of the pair
      #
      # @return [Node]
      attr_reader :key

      # Value of the pair
      #
      # @return [Node]
      attr_reader :value

      # Location of the +:+ or +=>+ operator
      #
      # @example
      #  { foo: bar }
      #       ~
      #
      #  { :foo => bar }
      #         ~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  { foo: bar }
      #    ~~~~~~~~
      #
      #  { :foo => bar }
      #    ~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a pattern based on a "pinned" variable (e.g. +^foo+)
    class Pin < Node
      # Variable that is pinned
      #
      # @return [Node]
      attr_reader :var

      # Location of the +^+ operator
      #
      # @example
      #  case foo; in ^bar; end
      #               ~
      #
      #
      # @return [Loc]
      attr_reader :selector_l

      # Location of the full expression
      #
      # @example
      #  case foo; in ^bar; end
      #               ~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents +END { .. }+ statement
    class Postexe < Node
      # Body of the block
      #
      # @return [Node, nil]
      attr_reader :body

      # Location of the +END+ keyword
      #
      # @example
      #  END { 42 }
      #  ~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the open parenthesis
      #
      # @example
      #  END { 42 }
      #      ~
      #
      #
      # @return [Loc]
      attr_reader :begin_l

      # Location of the closing parenthesis
      #
      # @example
      #  END { 42 }
      #           ~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  END { 42 }
      #  ~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents +BEGIN { ... }+ statement
    class Preexe < Node
      # Body of the block
      #
      # @return [Node, nil]
      attr_reader :body

      # Location of the +BEGIN+ keyword
      #
      # @example
      #  BEGIN { 42 }
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the open parenthesis
      #
      # @example
      #  BEGIN { 42 }
      #        ~
      #
      #
      # @return [Loc]
      attr_reader :begin_l

      # Location of the closing parenthesis
      #
      # @example
      #  BEGIN { 42 }
      #             ~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  BEGIN { 42 }
      #  ~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a sole block argument (e.g. +|foo|+)
    #
    # Block that takes a single array argument automatically expands it.
    # Adding trailing comma after block argument disables this behavior (and then the only argument is emitted as +Arg+).
    class Procarg0 < Node
      # Parts of the sole block argument.
      #
      # +proc { |(a, b)| }+ also counts as a sole argument, so this list may contain:
      # 1. A single +Arg+ node (for +proc { |a| }+ case)
      # 2. Multiple +Arg+ nodes  (for +proc { |(a, b, c)| }+ case)
      #
      # @return [::Array<Node>]
      attr_reader :args

      # Location of the open parenthesis
      #
      # @example
      #  proc { |(foo, bar)| }
      #          ~
      #
      # +None+ if there's only one argument
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the open parenthesis
      #
      # @example
      #  proc { |(foo, bar)| }
      #                   ~
      #
      # +None+ if there's only one argument
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  proc { |(foo, bar)| }
      #          ~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents rational literal (e.g. +1r+)
    class Rational < Node
      # String value of the literal, +String("1r")+ for +1r+
      #
      # @return [String]
      attr_reader :value

      # Location of the unary +-+ (but not +++)
      #
      # @example
      #  -1r
      #  ~
      #
      #
      # @return [Loc, nil]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  -1r
      #  ~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents +redo+ keyword
    class Redo < Node
      # Location of the full expression
      #
      # @example
      #  redo
      #  ~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents regex literal (e.g. +/foo/+)
    class Regexp < Node
      # A list of static and dynamic regex parts
      #
      # @return [::Array<Node>]
      attr_reader :parts

      # Regex options.
      #
      # +None+ if regex has no explicit flags
      #
      # @return [Node, nil]
      attr_reader :options

      # Location of the regex begin
      #
      # @example
      #  /foo/
      #  ~
      #
      #  %r{foo}
      #  ~~
      #
      #
      # @return [Loc]
      attr_reader :begin_l

      # Location of the regex end
      #
      # @example
      #  /foo/
      #      ~
      #
      #  %r{foo}
      #        ~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  /foo/mix
      #  ~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents flags of the regex literal (i.e. +mix+ for +/foo/mix+)
    class RegOpt < Node
      # A list of flags
      #
      # @return [String, nil]
      attr_reader :options

      # Location of the full expression
      #
      # @example
      #  /foo/mix
      #       ~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a +rescue+ block
    class Rescue < Node
      # Body of the block that is wrapped into +rescue+ (i.e. the part that may throw an error)
      #
      # @return [Node, nil]
      attr_reader :body

      # A list of +rescue+ handlers (see +RescueBody+ node)
      #
      # @return [::Array<Node>]
      attr_reader :rescue_bodies

      # Else branch.
      #
      # +None+ if there's no +else+ branch
      #
      # @return [Node, nil]
      attr_reader :else

      # Location of the +else+ keyword
      #
      # @example
      #  begin; 1; rescue StandardError => e; 2; else; 3; end
      #                                          ~~~~
      #
      # +None+ if there's no +else+ branch
      #
      # @return [Loc, nil]
      attr_reader :else_l

      # Location of the full expression
      #
      # @example
      #  begin; 1; rescue StandardError => e; 2; else; 3; end
      #         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      #
      # **Note**: +begin/end+ keywords belong to +KwBegin+ node
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a single +rescue+ handler (i.e. +rescue E => e ...+)
    class RescueBody < Node
      # A list of exception classes
      #
      # +None+ if no classes specified (i.e. +rescue => e; ...+ or just +rescue; ...+)
      #
      # @return [Node, nil]
      attr_reader :exc_list

      # Variable that captures exception
      #
      # +None+ if no variable specified (i.e. +rescue E; ...+ or just +rescue; ... +)
      #
      # @return [Node, nil]
      attr_reader :exc_var

      # Body of the handler
      #
      # @return [Node, nil]
      attr_reader :body

      # Location of the +rescue+ keyword
      #
      # @example
      #  begin; 1; rescue E => e; 2; end
      #            ~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +=>+ operator
      #
      # @example
      #  begin; 1; rescue E => e; 2; end
      #                     ~~
      #
      # +None+ if exception is not captured.
      #
      # @return [Loc, nil]
      attr_reader :assoc_l

      # Location of the +then+ keyword
      #
      # @example
      #  begin; 1; rescue E => e then; 2; end
      #                          ~~~~
      #
      # +then+ is optional, so +begin_l+ can be +None+
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the full expression
      #
      # @example
      #  begin; 1; rescue E => e then; 2; end
      #            ~~~~~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents positional rest argument (i.e. +*foo+ in +def m(*foo); end+)
    class Restarg < Node
      # Name of the argument.
      #
      # +None+ if argument has no name (i.e. +def m(*); end+)
      #
      # @return [String, nil]
      attr_reader :name

      # Location of the +*+ operator
      #
      # @example
      #  def m(*foo); end
      #        ~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the argument name
      #
      # @example
      #  def m(*foo); end
      #         ~~~
      #
      #
      # @return [Loc, nil]
      attr_reader :name_l

      # Location of the full expression
      #
      # @example
      #  def m(*foo); end
      #        ~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents +retry+ keyword
    class Retry < Node
      # Location of the +retry+ keyword
      #
      # @example
      #  retry
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents +return+ keyword
    class Return < Node
      # A list of values that is returned
      #
      # @return [::Array<Node>]
      attr_reader :args

      # Location of the +return+ keyword
      #
      # @example
      #  return 1, 2
      #  ~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the full expression
      #
      # @example
      #  return 1, 2
      #  ~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents opening a singleton class (i.e. +class << foo; ... end;+)
    class SClass < Node
      # Expression that is used to get a singleton class
      #
      # +Lvar("foo")+ for +class << foo; end+
      #
      # @return [Node]
      attr_reader :expr

      # Body of the block
      #
      # @return [Node, nil]
      attr_reader :body

      # Location of the +class+ keyword
      #
      # @example
      #  class << foo; end
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +<<+ operator
      #
      # @example
      #  class << foo; end
      #        ~~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the +end+ keyword
      #
      # @example
      #  class << foo; end
      #                ~~~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  class << foo; end
      #  ~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents +self+ keyword
    class Self_ < Node
      # Location of the +self+ keyword
      #
      # @example
      #  self
      #  ~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a method call (e.g. +foo.bar(42)+)
    class Send < Node
      # Receiver of the method call
      #
      # +None+ for implicit method call (e.g. +foo(42)+)
      #
      # @return [Node, nil]
      attr_reader :recv

      # Name of the method that is called
      #
      # @return [String]
      attr_reader :method_name

      # A list of arguments
      #
      # @return [::Array<Node>]
      attr_reader :args

      # Location of the +.+ operator
      #
      # @example
      #  foo.bar(42)
      #     ~
      #
      # +None+ for implicit method call (e.g. +foo(42)+)
      #
      # @return [Loc, nil]
      attr_reader :dot_l

      # Location of the method name
      #
      # @example
      #  foo.bar(42)
      #      ~~~
      #
      # +None+ in a very special case when method call is implicit (i.e. +foo.(42)+)
      #
      # @return [Loc, nil]
      attr_reader :selector_l

      # Location of open parenthesis
      #
      # @example
      #  foo(42)
      #     ~
      #
      # +None+ if there are no parentheses
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of closing parenthesis
      #
      # @example
      #  foo(42)
      #        ~
      #
      # +None+ if there are no parentheses
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the operator if method is a setter
      #
      # @example
      #  foo.bar = 42
      #          ~
      #
      # +None+ otherwise
      #
      # @return [Loc, nil]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  foo.bar(42)
      #  ~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a special block argument that "shadows" outer variable (i.e. +|;foo|+)
    class Shadowarg < Node
      # Name of the argument
      #
      # @return [String]
      attr_reader :name

      # Location of the argument
      #
      # @example
      #  proc { |;foo|}
      #           ~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an arguments splat (i.e. +*bar+ in a call like +foo(*bar)+)
    class Splat < Node
      # Value that is converted to array
      #
      # @return [Node, nil]
      attr_reader :value

      # Location of the +*+ operator
      #
      # @example
      #  foo(*bar)
      #      ~
      #
      #
      # @return [Loc]
      attr_reader :operator_l

      # Location of the full expression
      #
      # @example
      #  foo(*bar)
      #      ~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a plain non-interpolated string literal (e.g. +"foo"+)
    class Str < Node
      # Value of the string literal
      #
      # Note that it's a +StringValue+, not a +String+.
      # The reason is that you can get UTF-8 incompatible strings
      # from a valid UTF-8 source using escape sequences like +"\xFF"+
      #
      # These "\", "x", "F", "F" chars are valid separately, but together
      # they construct a char with code = 255 that is invalid for UTF-8.
      #
      # You can use +to_string_lossy+ or +to_string+ methods to get a raw string value.
      #
      # @return [String]
      attr_reader :value

      # Location of the string begin
      #
      # @example
      #  "foo"
      #  ~
      #
      # +None+ if string literal is a part of the words array (like +%w[foo bar baz]+)
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the string begin
      #
      # @example
      #  "foo"
      #      ~
      #
      # +None+ if string literal is a part of the words array (like +%w[foo bar baz]+)
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  "foo"
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a +super+ keyword
    class Super < Node
      # A list of arguments given to +super+
      #
      # @return [::Array<Node>]
      attr_reader :args

      # Location of the +super+ keyword
      #
      # @example
      #  super(1, 2)
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the open parenthesis
      #
      # @example
      #  super(1, 2)
      #       ~
      #
      # +None+ if there are no parentheses
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the closing parenthesis
      #
      # @example
      #  super(1, 2)
      #            ~
      #
      # +None+ if there are no parentheses
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  super(1, 2)
      #  ~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a plain symbol literal (i.e. +:foo+)
    #
    # Note that +:+ in +{ foo: bar }+ belongs to a +pair+ node.
    class Sym < Node
      # Value of the symbol literal
      #
      # Note that it's a +StringValue+, not a +String+.
      # The reason is that you can get UTF-8 incompatible strings
      # from a valid UTF-8 source using escape sequences like +"\xFF"+
      #
      # These "\", "x", "F", "F" chars are valid separately, but together
      # they construct a char with code = 255 that is invalid for UTF-8.
      #
      # You can use +to_string_lossy+ or +to_string+ methods to get a raw symbol value.
      #
      # @return [String]
      attr_reader :name

      # Location of the symbol begin
      #
      # @example
      #  :foo
      #  ~
      #
      # +None+ if symbol is a label (+{ foo: 1 }+) or a part of the symbols array (+%i[foo bar baz]+)
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the symbol end
      #
      # @example
      #  { 'foo': 1 }
      #         ~
      #
      # +None+ if symbol is **not** a string label (+:foo+) or a part of the symbols array (+%i[foo bar baz]+)
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  :foo
      #  ~~~~
      #
      #  { foo: 1 }
      #    ~~~~
      #
      #  %i[foo]
      #     ~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a +true+ literal
    class True < Node
      # Location of the +true+ keyword
      #
      # @example
      #  true
      #  ~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an +undef+ keyword (e.g. +undef foo, :bar+)
    class Undef < Node
      # A list of names to +undef+
      #
      # @return [::Array<Node>]
      attr_reader :names

      # Location the +undef+ keyword
      #
      # @example
      #  undef foo, :bar
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the full expression
      #
      # @example
      #  undef :foo, bar
      #  ~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an +unless+ guard used in pattern matching (i.e. +in pattern unless guard+)
    class UnlessGuard < Node
      # Condition of the guard, +Lvar("foo")+ in +in pattern unless guard+
      #
      # @return [Node]
      attr_reader :cond

      # Location of the +unless+ keyword
      #
      # @example
      #  case foo; in pattern unless cond; end
      #                       ~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the full expression
      #
      # @example
      #  case foo; in pattern unless cond; end
      #                       ~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents +until+ loop
    class Until < Node
      # Condition of the loop
      #
      # @return [Node]
      attr_reader :cond

      # Body of the loop.
      #
      # +None+ if body is empty
      #
      # @return [Node, nil]
      attr_reader :body

      # Location of the +until+ keyword
      #
      # @example
      #  until cond do; foo; end
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +do+ keyword
      #
      # @example
      #  until cond do; foo; end
      #             ~~
      #
      # +do+ is optional, and so +begin_l+ can be +None+
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the +end+ keyword
      #
      # @example
      #  until cond do; foo; end
      #                      ~~~
      #
      # +None+ if loop is a modifier (i.e. +foo until bar+)
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  until cond do; foo; end
      #  ~~~~~~~~~~~~~~~~~~~~~~~
      #
      #  foo until bar
      #  ~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a post-until loop
    #
    # @example
    #  begin
    #  foo
    #  end until bar
    #
    class UntilPost < Node
      # Condition of the loop
      #
      # @return [Node]
      attr_reader :cond

      # Body of the loop
      #
      # @return [Node]
      attr_reader :body

      # Location of the +until+ keyword
      #
      # @example
      #  begin; foo; end until bar
      #                  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +until+ keyword
      #
      # @example
      #  begin; foo; end until bar
      #  ~~~~~~~~~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a branch of the +case+ statement (i.e. +when foo+)
    class When < Node
      # A list of values to compare/match against
      #
      # @return [::Array<Node>]
      attr_reader :patterns

      # Body of the +when+ branch
      #
      # @return [Node, nil]
      attr_reader :body

      # Location of the +when+ keyword
      #
      # @example
      #  case foo; when bar; end
      #            ~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +then+ keyword
      #
      # @example
      #  case foo; when bar then baz; end
      #                     ~~~~
      #
      # +then+ is optional, and so +begin_l+ can be +None+
      #
      # @return [Loc]
      attr_reader :begin_l

      # Location of the full expression
      #
      # @example
      #  case foo; when bar then baz; end
      #            ~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents +while+ loop
    class While < Node
      # Condition of the loop
      #
      # @return [Node]
      attr_reader :cond

      # Body of the loop.
      #
      # +None+ if body is empty
      #
      # @return [Node, nil]
      attr_reader :body

      # Location of the +while+ keyword
      #
      # @example
      #  while cond do; foo; end
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +do+ keyword
      #
      # @example
      #  while cond do; foo; end
      #             ~~
      #
      # +do+ is optional, and so +begin_l+ can be +None+
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the +end+ keyword
      #
      # @example
      #  while cond do; foo; end
      #                      ~~~
      #
      # +None+ if loop is a modifier (i.e. +foo while bar+)
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  while cond do; foo; end
      #  ~~~~~~~~~~~~~~~~~~~~~~~
      #
      #  foo while bar
      #  ~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a post-while loop
    #
    # @example
    #  begin
    #  foo
    #  end while bar
    #
    class WhilePost < Node
      # Condition of the loop
      #
      # @return [Node]
      attr_reader :cond

      # Body of the loop
      #
      # @return [Node]
      attr_reader :body

      # Location of the +while+ keyword
      #
      # @example
      #  begin; foo; end while bar
      #                  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the +while+ keyword
      #
      # @example
      #  begin; foo; end while bar
      #  ~~~~~~~~~~~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a executable here-document literal (both with and without interpolation)
    #
    # It's similar to +Xstr+ in terms of abstract syntax tree, but has different source maps.
    class XHeredoc < Node
      # A list of string parts (static literals and interpolated expressions)
      #
      # @return [::Array<Node>]
      attr_reader :parts

      # Location of the executable here-document body
      #
      # @example
      #  <<-`HERE`\n  a\n   #{42}\nHERE
      #           ~~~~~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :heredoc_body_l

      # Location of the executable here-document end
      #
      # @example
      #  <<-`HERE`\n  a\n   #{42}\nHERE
      #                            ~~~~
      #
      #
      # @return [Loc]
      attr_reader :heredoc_end_l

      # Location of the executable here-document identifier
      #
      # @example
      #  <<-`HERE`\n  a\n   #{42}\nHERE
      #  ~~~~~~~
      #
      # **Note**: This is the only node (with +Heredoc+) that has +expression_l+ smaller that all other sub-locations merged.
      # The reason for that is that it's possible to add more code after here-document ID:
      #
      # @example
      #  <<-`HERE` + "rest"
      #  content
      #  HERE
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an executable string (i.e. + +sh #{script_name}+ +)
    class Xstr < Node
      # A list of string parts (static literals and interpolated expressions)
      #
      # @return [::Array<Node>]
      attr_reader :parts

      # Location of the string begin
      #
      # @example
      #  `#{foo}`
      #  ~
      #
      #  %X{#{foo}}
      #  ~~~
      #
      #
      # @return [Loc]
      attr_reader :begin_l

      # Location of the string end
      #
      # @example
      #  `#{foo}`
      #         ~
      #
      #  %X{#{foo}}
      #           ~
      #
      #
      # @return [Loc]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  `#{foo}`
      #  ~~~~~~~~
      #
      #  %X{#{foo}}
      #  ~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents an +yield+ keyword
    class Yield < Node
      # A list of arguments given to +yield+
      #
      # @return [::Array<Node>]
      attr_reader :args

      # Location of the +yield+ keyword
      #
      # @example
      #  yield 1, 2
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :keyword_l

      # Location of the open parenthesis
      #
      # @example
      #  yield(1, 2)
      #       ~
      #
      # +None+ if there are no parentheses
      #
      # @return [Loc, nil]
      attr_reader :begin_l

      # Location of the closing parenthesis
      #
      # @example
      #  yield(1, 2)
      #            ~
      #
      # +None+ if there are no parentheses
      #
      # @return [Loc, nil]
      attr_reader :end_l

      # Location of the full expression
      #
      # @example
      #  yield(1, 2)
      #  ~~~~~~~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

    # Represents a +super+ call without arguments and parentheses
    #
    # It's different from +super()+ as it implicitly forwards current arguments
    class ZSuper < Node
      # Location of the +super+ keyword
      #
      # @example
      #  super
      #  ~~~~~
      #
      #
      # @return [Loc]
      attr_reader :expression_l

    end

  end
end
